-- +goose Up
-- +goose StatementBegin
CREATE SCHEMA internal;
CREATE TABLE internal.calendar ();
-- Creating video schema, all video related tables stored here
CREATE SCHEMA video;
-- We will initate the tables in the following order,
-- in order to ensure that the foreign keys get setup:
-- 1. video.series
-- 2. video.items
-- 3. video.playlists
-- 4. video.playlist_items
-- 5. video.presets
-- 6. video.encode_formats
-- 7. video.presets_encode_formats
-- 8. video.files
-- Then migrate the data in the same order.
-- (We won't need to migrate playlists due to it being new)
CREATE TABLE video.series (
    series_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parent_series_id int REFERENCES video.series(series_id),
    name text,
    url text NOT NULL,
    description text,
    thumbnail text,
    tags text [],
    status text,
    series_position smallint,
    created_at timestamptz NOT NULL DEFAULT NOW(),
    created_by int,
    updated_at timestamptz,
    updated_by int,
    deleted_at timestamptz,
    deleted_by int
);
-- Name if null should fallback to use the URL.
-- Series position indicates its position in relation to
-- it's siblings.
-- video.items table stores every video
CREATE TABLE video.items (
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    url text,
    description text,
    thumbnail text,
    duration interval,
    views int NOT NULL DEFAULT 0,
    genre int NOT NULL DEFAULT 0,
    tags text [],
    series int,
    series_position smallint,
    status text NOT NULL DEFAULT 'internal',
    preset int REFERENCES video.presets(id),
    broadcast_date timestamptz NOT NULL,
    created_at timestamptz NOT NULL DEFAULT NOW(),
    created_by int DEFAULT 0,
    updated_at timestamptz,
    updated_by int,
    deleted_at timestamptz,
    deleted_by int
);
-- video.playlists essentially youtube playlists
CREATE TABLE video.playlists (
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    description text,
    thumbnail text,
    status text NOT NULL DEFAULT 'internal',
    created_at timestamptz NOT NULL,
    created_by int NOT NULL,
    updated_at timestamptz,
    updated_by int,
    deleted_at timestamptz,
    deleted_by int
);
-- We need to map that many to many relationship
CREATE TABLE video.playlist_items (
    playlist_id int REFERENCES video.playlist(id) ON UPDATE CASCADE ON DELETE CASCADE,
    video_item_id REFERENCES video.items(id) ON UPDATE CASCADE,
    position smallint,
    CONSTRAINT video.playlists_items_pkey PRIMARY KEY (playlist_id video_item_id)
);
-- The files each have an encode_format that is used to convert the
-- source file using the encode_format params to create the file.
-- A video item can have a preset selected which will generate
-- A group of encode_formats for a video, this saves time since
-- we can specify once that we need these specific qualities and
-- all videos will follow that rule.
CREATE TABLE video.presets (
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    description text,
);
CREATE TABLE video.encode_formats (
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    description text,
    type text,
    arguements text NOT NULL,
    watermarked bool NOT NULL
);
CREATE TABLE video.presets_encode_formats (
    preset_id int REFERENCES video.preset(id) ON UPDATE CASCADE ON DELETE CASCADE,
    encode_format_id REFERENCES video.encode_formats(id) ON UPDATE CASCADE,
    CONSTRAINT video.presets_encode_formats_pkey PRIMARY KEY (preset_id encode_format_id)
);
CREATE TABLE video.files (
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    video_id int NOT NULL REFERENCES video.items(id),
    uri text NOT NULL,
    status text,
    encode_format int NOT NULL REFERENCES video.encode_formats(id),
    size bigint,
);
COMMENT ON TABLE video.files IS 'Supporting video files for a video item';
COMMENT ON COLUMN video.files.status IS 'Indicates status of the file i.e. available, internal, error';
COMMENT ON COLUMN video.files.size IS 'Measured in kilobytes (KB)';
-- Migrations
-- Migration from public.videos to video.items
INSERT INTO video.items (
        id,
        name,
        url,
        description,
        duration,
        tags,
        series,
        series_position,
        status,
        broadcast_date,
        created_at,
        created_by
    )
SELECT id,
    display_name,
    url_name,
    description,
    duration,
    regexp_split_to_array(keywords, ' '),
    video_box_id,
    ordering,
    CASE
        WHEN is_enabled THEN 'public'
        ELSE 'internal'
    END,
    created_date,
    created_date,
    created_by
FROM public.videos;
-- Migration from public.video_boxes to video.series
INSERT INTO video.series (
        series_id,
        url,
        name,
        description,
        thumbnail,
        status
    )
SELECT id,
    url_name,
    display_name,
    description,
    image,
    CASE
        WHEN is_public THEN 'public'
        ELSE 'internal'
    END
FROM public.video_boxes;
-- +goose StatementEnd
-- +goose Down
-- +goose StatementBegin
DROP SCHEMA videos;
-- +goose StatementEnd