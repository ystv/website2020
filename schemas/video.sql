-- Creating video schema, all video related tables stored here
CREATE SCHEMA video;
-- We will initate the tables in the following order,
-- in order to ensure that the foreign keys get setup:
-- 1. video.series
-- 2. video.presets
-- 3. video.encode_formats
-- 4. video.presets_encode_formats
-- 5. video.items
-- 6. video.playlists
-- 7. video.playlist_items
-- 8. video.files
-- Then migrate the data in the same order.
-- (We won't need to migrate playlists due to it being new)
--
-- video.series table represents a group of videos, recursive and a video belongs to one series only
--
CREATE TABLE video.series (
    series_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    lft int NOT NULL,
    rgt int NOT NULL,
    name text NOT NULL,
    in_url boolean NOT NULL DEFAULT TRUE,
    url text NOT NULL,
    description text NOT NULL DEFAULT '',
    thumbnail text NOT NULL DEFAULT '',
    tags text [] NOT NULL DEFAULT array[]::text[],
    status text NOT NULL DEFAULT 'internal',
    created_at timestamptz NOT NULL DEFAULT NOW(),
    created_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    updated_at timestamptz,
    updated_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    deleted_at timestamptz,
    deleted_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT created_chk CHECK (created_at <= updated_at AND created_at <= deleted_at),
    CONSTRAINT updated_chk CHECK (updated_at >= created_at AND updated_at <= deleted_at),
    CONSTRAINT deleted_chk CHECK (deleted_at >= created_at AND deleted_at >= updated_at),
    CONSTRAINT status_chk CHECK (status IN ('private', 'internal', 'public'))
);
-- The files each have an encode_format that is used to convert the
-- source file using the encode_format params to create the file.
-- A video item can have a preset selected which will generate
-- A group of encode_formats for a video, this saves time since
-- we can specify once that we need these specific qualities and
-- all videos will follow that rule.
CREATE TABLE video.encode_presets (
    preset_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    description text NOT NULL DEFAULT ''
);
CREATE TABLE video.encode_formats (
    format_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    description text NOT NULL DEFAULT '',
    mime_type text NOT NULL,
    mode text NOT NULL,
    width int NOT NULL,
    height int NOT NULL,
    arguments text NOT NULL,
    file_suffix text NOT NULL,
    watermarked bool NOT NULL
);
COMMENT ON COLUMN video.encode_formats.file_suffix IS
'When a video has been created by this format, it will be stored with the existing
filename + the file_suffix. If there is no file_suffix is will use the format ID';
CREATE TABLE video.encode_preset_formats (
    preset_id int REFERENCES video.encode_presets(preset_id) ON UPDATE CASCADE ON DELETE CASCADE,
    format_id int REFERENCES video.encode_formats(format_id) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT presets_encode_formats_pkey PRIMARY KEY (preset_id, format_id)
);
--
-- video.items table stores every video
--
-- Name if null should fallback to use the URL.
-- Series position indicates its position in relation to
-- it's siblings.
CREATE TABLE video.items (
    video_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    series_id int NOT NULL REFERENCES video.series(series_id) ON UPDATE CASCADE ON DELETE CASCADE,
    name text NOT NULL,
    url text NOT NULL,
    description text NOT NULL DEFAULT '',
    thumbnail text NOT NULL DEFAULT '',
    duration int NOT NULL DEFAULT 0,
    views int NOT NULL DEFAULT 0,
    genre int NOT NULL DEFAULT 0,
    tags text [] NOT NULL DEFAULT array[]::text[],
    series_position smallint,
    status text NOT NULL DEFAULT 'internal',
    preset_id int REFERENCES video.encode_presets(preset_id) ON UPDATE CASCADE ON DELETE SET NULL,
    broadcast_date timestamptz NOT NULL DEFAULT NOW(),
    created_at timestamptz NOT NULL DEFAULT NOW(),
    created_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    updated_at timestamptz,
    updated_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    deleted_at timestamptz,
    deleted_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT created_chk CHECK (created_at <= updated_at AND created_at <= deleted_at),
    CONSTRAINT updated_chk CHECK (updated_at >= created_at AND updated_at <= deleted_at),
    CONSTRAINT deleted_chk CHECK (deleted_at >= created_at AND deleted_at >= updated_at),
    CONSTRAINT status_chk CHECK (status IN ('processing', 'private', 'internal', 'public'))
);
COMMENT ON COLUMN video.items.duration IS
'Seconds is accurate enough for VOD. Playout software should probe
the file and store it''s own time, maybe in ms?';
--
-- video.playlists essentially youtube playlists
--
CREATE TABLE video.playlists (
    playlist_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    description text NOT NULL DEFAULT '',
    thumbnail text NOT NULL DEFAULT '',
    status text NOT NULL DEFAULT 'internal',
    created_at timestamptz NOT NULL DEFAULT NOW(),
    created_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    updated_at timestamptz,
    updated_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    deleted_at timestamptz,
    deleted_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL
);
--
-- We need to map that many to many relationship
--
CREATE TABLE video.playlist_items (
    playlist_id int REFERENCES video.playlists(playlist_id) ON UPDATE CASCADE ON DELETE CASCADE,
    video_item_id int REFERENCES video.items(video_id) ON UPDATE CASCADE ON DELETE CASCADE,
    position smallint,
    CONSTRAINT playlist_items_pkey PRIMARY KEY (playlist_id, video_item_id)
);
--
-- video.files store the actual media, both source and for delivery
-- 
CREATE TABLE video.files (
    file_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    video_id int NOT NULL REFERENCES video.items(video_id) ON UPDATE CASCADE ON DELETE CASCADE,
    format_id int NOT NULL REFERENCES video.encode_formats(format_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    uri text NOT NULL,
    status text NOT NULL,
    size bigint NOT NULL DEFAULT 0,
    is_source bool NOT NULL DEFAULT false,
    CONSTRAINT status_chk CHECK (status IN ('processing', 'private', 'internal', 'public'))
);
COMMENT ON TABLE video.files IS 'Supporting video files for a video item';
COMMENT ON COLUMN video.files.status IS 'Indicates status of the file i.e. public, internal, error';
COMMENT ON COLUMN video.files.size IS 'Measured in kilobytes (KB)';
COMMENT ON COLUMN video.files.is_source IS 'When we attempt to create a VOD of a video, this file would be used as the source';
--
-- video.hits stores every video hit
CREATE TABLE video.hits (
    hit_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    start_time timestamptz NOT NULL,
    mode text NOT NULL,
    ip_address inet NOT NULL,
    client_info text NOT NULL,
    percent integer NOT NULL,
    video_id int NOT NULL REFERENCES video.items(video_id) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT modechk CHECK (mode IN ('watch', 'download', 'embed'))
);
CREATE INDEX starttime ON video.hits USING btree(start_time);
--
-- Views
--
-- View to easily turn URLs to series
CREATE VIEW video.series_paths AS
SELECT node.series_id,
    array_to_string(
        array_agg(
            parent.url
            ORDER BY parent.lft ASC
        ),
        '/'
    ) path,
    node.status
FROM video.series AS node,
    video.series AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
    AND parent.in_url
GROUP BY node.series_id
ORDER BY node.lft;
