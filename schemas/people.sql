-- Creating our people schema which will store personal data and whatnot
-- so we'll be trying to keep things in there and clamp down on access.
CREATE SCHEMA people;
-- We will create the tables in the following order
-- 1. people.users REFERENCES people.users
-- 2. people.roles
-- 3. people.role_members REFERENCES people.users, people.roles
-- 4. people.permissions
-- 5. people.role_permissions REFERENCES people.roles, people.permissions
--
-- Then we will then migrate from the old database
--
-- people.users stores the global user information
CREATE TABLE people.users (
    user_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username text NOT NULL UNIQUE,
    email text UNIQUE,
    first_name text NOT NULL,
    last_name text NOT NULL,
    nickname text NOT NULL,
    login_type text NOT NULL,
    password text NOT NULL,
    salt text NOT NULL,
    avatar text,
    last_login timestamptz,
    reset_pw boolean NOT NULL DEFAULT true,
    enabled boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT NOW(),
    created_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    updated_at timestamptz,
    updated_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    deleted_at timestamptz,
    deleted_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT loginchk CHECK (login_type IN ('internal', 'sso'))
);
COMMENT ON COLUMN people.users.email IS 'Would be not null, but we have existing data';
COMMENT ON COLUMN people.users.login_type IS 'internal - uses pw in this table to authenticate. sso - uses external auth';
--
-- people.roles implementing RBAC, user can have many roles, roles have many permissions
CREATE TABLE people.roles (
    role_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text
);
--
-- people.role_members stores which user is a member of a role
CREATE TABLE people.role_members (
    user_id int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE CASCADE,
    role_id int REFERENCES people.roles(role_id) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT role_members_pkey PRIMARY KEY (user_id, role_id)
);
--
-- people.permissions stores the individual permission item which can be part of many roles
CREATE TABLE people.permissions (
    permission_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text
);
--
-- people.role_permissions maps a role to a permissions
CREATE TABLE people.role_permissions (
    role_id int REFERENCES people.roles(role_id) ON UPDATE CASCADE ON DELETE CASCADE,
    permission_id int REFERENCES people.permissions(permission_id) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT role_permissions_pkey PRIMARY KEY (role_id, permission_id)
);
--
-- people.officerships
CREATE TABLE people.officerships(
    officer_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    email_alias text NOT NULL DEFAULT 'station',
    description text NOT NULL DEFAULT '',
    historywiki_url text NOT NULL DEFAULT '',
    role_id int REFERENCES people.roles(role_id),
    is_current bool NOT NULL DEFAULT true,
    if_unfilled int REFERENCES people.officerships(officer_id)
);
COMMENT ON COLUMN people.officerships.role_id IS 'Allows user who currently has officership to inherit role''s permissions';
--
-- people.officership_members
CREATE TABLE people.officership_members(
    officership_member_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    officer_id int NOT NULL REFERENCES people.officerships(officer_id) ON UPDATE CASCADE ON DELETE CASCADE,
    start_date timestamptz,
    end_date timestamptz
);
COMMENT ON TABLE people.officership_members IS 'Records of what user has been in what officership with time';
--
-- people.officership_teams
CREATE TABLE people.officership_teams(
    team_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    email_alias text NOT NULL DEFAULT 'station',
    short_description text NOT NULL DEFAULT '',
    full_description text NOT NULL DEFAULT ''
);
COMMENT ON TABLE people.officership_teams IS 'This would be the organisational units of the socieity i.e. comp team, admin team, etc';
COMMENT ON COLUMN people.officership_teams.full_description IS 'Markdown formatted. Hopefully could be used to build out proper team pages';
--
-- people.officership_team_members
CREATE TABLE people.officership_team_members(
    team_id int REFERENCES people.officership_teams(team_id) ON UPDATE CASCADE ON DELETE CASCADE,
    officer_id int REFERENCES people.officerships(officer_id) ON UPDATE CASCADE ON DELETE CASCADE,
    is_leader bool NOT NULL,
    is_deputy bool NOT NULL,
    CONSTRAINT officership_team_members_pkey PRIMARY KEY (team_id, officer_id),
    CHECK ( NOT (is_leader IS TRUE AND is_deputy IS TRUE) )
);
COMMENT ON TABLE people.officership_team_members IS 'Officerships that are part of a team';
--
-- Migrations
--
-- Migration public.members to people.users
INSERT INTO people.users (
        user_id,
        username,
        email,
        first_name,
        last_name,
        nickname,
        login_type,
        password,
        salt,
        avatar,
        last_login,
        reset_pw,
        created_at,
        created_by,
        updated_at,
        updated_by
    )
SELECT id,
    COALESCE(
        username,
        server_name,
        email_address,
        LOWER(
            CONCAT(first_name, '.', last_name, '.', id::text)
        )
    ),
    CASE
        WHEN (COALESCE(email_address, '') = '') THEN CONCAT('noreply+', id::text, '@ystv.co.uk')
        ELSE email_address
    END AS email_address,
    first_name,
    last_name,
    first_name,
    'internal',
    COALESCE(newpw, ''),
    salt,
    photo_file,
    last_logged_in,
    force_pw_reset,
    created_date,
    created_by,
    last_edited_date,
    last_edited_by
FROM public.members;
--
-- Migration public.member_groups to people.roles
INSERT INTO people.roles (name, description)
SELECT name,
    description
FROM public.member_groups;
--
-- Migration public.member_group_members to people.role_members
INSERT INTO people.role_members (user_id, role_id)
SELECT gm.member_id,
    roles.role_id
FROM public.member_group_members gm
    LEFT JOIN people.roles roles ON member_group_name = roles.name;
--
-- Migration public.permissions to people.permissions
INSERT INTO people.permissions (name, description)
SELECT name,
    description
FROM public.permissions;
--
-- Migration public.member_group_permissions to people.role_permissions
INSERT INTO people.role_permissions (role_id, permission_id)
SELECT roles.role_id,
    perm.permission_id
FROM public.member_group_permissions oldgrp
    LEFT JOIN people.roles roles ON oldgrp.member_group_name = roles.name
    LEFT JOIN people.permissions perm ON oldgrp.permission_name = perm.name;
--
-- Migration from public.officerships to people.officerships
INSERT INTO people.officerships(name, description, email_alias, is_current)
SELECT name,
    COALESCE(description, ''),
    email_alias,
    is_current
FROM public.officerships;
-- we don't do if_unfilled since we need the data source to exist first
-- so not gonna faff with it.
-- Also not faffing with migrating the officership permissions, can be made manually.
--
-- Migration from public.member_officerships to people.officership_members
INSERT INTO people.officership_members(officership_member_id, user_id, officer_id, start_date, end_date)
SELECT id,
    member_id,
    officer_id,
    start_date,
    end_date
FROM public.member_officerships
INNER JOIN people.officerships ON officership_name = name;
--
-- Migration from public.officerships to people.officership_teams
INSERT INTO people.officership_teams(name)
SELECT DISTINCT team FROM public.officerships WHERE team IS NOT NULL;
--
-- Migration from public.officerships to people.officership_team_members
INSERT INTO people.officership_team_members(team_id, officer_id, is_leader, is_deputy)
SELECT team_id, officer_id, is_team_leader, is_team_deputy
FROM public.officerships old_off
INNER JOIN people.officerships new_off ON old_off.name = new_off.name
INNER JOIN people.officership_teams team ON old_off.team = team.name; 
