-- Creating our people schema which will store personal data and whatnot
-- so we'll be trying to keep things in there and clamp down on access.
CREATE SCHEMA people;
-- We will initiate the tables in the following order
-- 1. people.users REFERENCES people.users
-- 2. people.roles
-- 3. people.role_members REFERENCES people.users, people.roles
-- 4. people.permissions
-- 5. people.role_permissions REFERENCES people.roles, people.permissions
--
-- people.users stores the global user information
CREATE TABLE people.users (
    user_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username text NOT NULL UNIQUE,
    email text UNIQUE,
    first_name text NOT NULL,
    last_name text NOT NULL,
    nickname text NOT NULL,
    password text NOT NULL,
    salt text NOT NULL,
    avatar text,
    last_login timestamptz,
    reset_pw boolean NOT NULL DEFAULT true,
    enabled boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT NOW(),
    created_by int REFERENCES people.users(user_id),
    updated_at timestamptz,
    updated_by int REFERENCES people.users(user_id),
    deleted_at timestamptz,
    deleted_by int REFERENCES people.users(user_id)
);
COMMENT ON COLUMN people.users.email IS 'Would be not null, but we have existing data';
--
-- people.roles implementing RBAC, user can have many roles, roles have many permissions
CREATE TABLE people.roles (
    role_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text
);
--
-- people.role_members stores which user is a member of a role
CREATE TABLE people.role_members (
    user_id int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE CASCADE,
    role_id int REFERENCES people.roles(role_id) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT role_members_pkey PRIMARY KEY (user_id, role_id)
);
--
-- people.permissions stores the individual permission item which can be part of many roles
CREATE TABLE people.permissions (
    permission_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text
);
--
-- people.role_permissions maps a role to a permissions
CREATE TABLE people.role_permissions (
    role_id int REFERENCES people.roles(role_id) ON UPDATE CASCADE ON DELETE CASCADE,
    permission_id int REFERENCES people.permissions(permission_id) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT role_permissions_pkey PRIMARY KEY (role_id, permission_id)
);
--
-- Migrations
--
-- Migration public.members to people.users
INSERT INTO people.users (
        user_id,
        username,
        email,
        first_name,
        last_name,
        nickname,
        password,
        salt,
        avatar,
        last_login,
        reset_pw,
        created_at,
        created_by,
        updated_at,
        updated_by
    )
SELECT id,
    COALESCE(
        username,
        server_name,
        email_address,
        LOWER(
            CONCAT(first_name, '.', last_name, '.', id::text)
        )
    ),
    CASE
        WHEN (COALESCE(email_address, '') = '') THEN CONCAT('noreply+', id::text, '@ystv.co.uk')
        ELSE email_address
    END AS email_address,
    first_name,
    last_name,
    first_name,
    COALESCE(newpw, ''),
    salt,
    photo_file,
    last_logged_in,
    force_pw_reset,
    created_date,
    created_by,
    last_edited_date,
    last_edited_by
FROM public.members;
--
-- Migration public.member_groups to people.roles
INSERT INTO people.roles (name, description)
SELECT name,
    description
FROM public.member_groups;
--
-- Migration public.member_group_members to people.role_members
INSERT INTO people.role_members (user_id, role_id)
SELECT gm.member_id,
    roles.role_id
FROM public.member_group_members gm
    LEFT JOIN people.roles roles ON member_group_name = roles.name;
--
-- Migration public.permissions to people.permissions
INSERT INTO people.permissions (name, description)
SELECT name,
    description
FROM public.permissions;
--
-- Migration public.member_group_permissions to people.role_permissions
INSERT INTO people.role_permissions (role_id, permission_id)
SELECT roles.role_id,
    perm.permission_id
FROM public.member_group_permissions oldgrp
    LEFT JOIN people.roles roles ON oldgrp.member_group_name = roles.name
    LEFT JOIN people.permissions perm ON oldgrp.permission_name = perm.name;