-- Creating our people schema which will store personal data and whatnot
-- so we'll be trying to keep things in there and clamp down on access.
CREATE SCHEMA IF NOT EXISTS people;
-- We will create the tables in the following order
-- 1. people.users REFERENCES people.users
-- 2. people.roles
-- 3. people.role_members REFERENCES people.users, people.roles
-- 4. people.permissions
-- 5. people.role_permissions REFERENCES people.roles, people.permissions
--
-- Then we will then migrate from the old database
--
-- people.users stores the global user information
CREATE TABLE people.users (
    user_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username text NOT NULL UNIQUE,
    email text NOT NULL UNIQUE,
    first_name text NOT NULL,
    last_name text NOT NULL,
    nickname text NOT NULL DEFAULT '',
    login_type text NOT NULL,
    password text NOT NULL,
    salt text NOT NULL,
    avatar text NOT NULL DEFAULT '',
    last_login timestamptz,
    reset_pw boolean NOT NULL DEFAULT true,
    enabled boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT NOW(),
    created_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    updated_at timestamptz,
    updated_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    deleted_at timestamptz,
    deleted_by int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT loginchk CHECK (login_type IN ('internal', 'sso'))
);
COMMENT ON COLUMN people.users.email IS 'Would be not null, but we have existing data';
COMMENT ON COLUMN people.users.login_type IS 'internal - uses pw in this table to authenticate. sso - uses external auth';
--
-- people.roles implementing RBAC, user can have many roles, roles have many permissions
CREATE TABLE people.roles (
    role_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text NOT NULL DEFAULT ''
);
--
-- people.role_members stores which user is a member of a role
CREATE TABLE people.role_members (
    user_id int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE CASCADE,
    role_id int REFERENCES people.roles(role_id) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT role_members_pkey PRIMARY KEY (user_id, role_id)
);
--
-- people.permissions stores the individual permission item which can be part of many roles
CREATE TABLE people.permissions (
    permission_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text NOT NULL DEFAULT ''
);
--
-- people.role_permissions maps a role to a permissions
CREATE TABLE people.role_permissions (
    role_id int NOT NULL REFERENCES people.roles(role_id) ON UPDATE CASCADE ON DELETE CASCADE,
    permission_id int NOT NULL REFERENCES people.permissions(permission_id) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT role_permissions_pkey PRIMARY KEY (role_id, permission_id)
);
--
-- people.officerships
CREATE TABLE people.officerships(
    officer_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    email_alias text NOT NULL DEFAULT 'station',
    description text NOT NULL DEFAULT '',
    historywiki_url text NOT NULL DEFAULT '',
    role_id int REFERENCES people.roles(role_id) ON UPDATE CASCADE ON DELETE SET NULL,
    is_current bool NOT NULL DEFAULT true,
    if_unfilled int REFERENCES people.officerships(officer_id)
);
COMMENT ON COLUMN people.officerships.role_id IS 'Allows user who currently has officership to inherit role''s permissions';
--
-- people.officership_members
CREATE TABLE people.officership_members(
    officership_member_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id int REFERENCES people.users(user_id) ON UPDATE CASCADE ON DELETE SET NULL,
    officer_id int NOT NULL REFERENCES people.officerships(officer_id) ON UPDATE CASCADE ON DELETE CASCADE,
    start_date timestamptz,
    end_date timestamptz
);
COMMENT ON TABLE people.officership_members IS 'Records of what user has been in what officership with time';
--
-- people.officership_teams
CREATE TABLE people.officership_teams(
    team_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    email_alias text NOT NULL DEFAULT 'station',
    short_description text NOT NULL DEFAULT '',
    full_description text NOT NULL DEFAULT ''
);
COMMENT ON TABLE people.officership_teams IS 'This would be the organisational units of the socieity i.e. comp team, admin team, etc';
COMMENT ON COLUMN people.officership_teams.full_description IS 'Markdown formatted. Hopefully could be used to build out proper team pages';
--
-- people.officership_team_members
CREATE TABLE people.officership_team_members(
    team_id int NOT NULL REFERENCES people.officership_teams(team_id) ON UPDATE CASCADE ON DELETE CASCADE,
    officer_id int NOT NULL REFERENCES people.officerships(officer_id) ON UPDATE CASCADE ON DELETE CASCADE,
    is_leader bool NOT NULL,
    is_deputy bool NOT NULL,
    CONSTRAINT officership_team_members_pkey PRIMARY KEY (team_id, officer_id),
    CHECK ( NOT (is_leader IS TRUE AND is_deputy IS TRUE) )
);
COMMENT ON TABLE people.officership_team_members IS 'Officerships that are part of a team';
